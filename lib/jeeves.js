// Generated by CoffeeScript 1.7.1

/*
 *  Jeeves
 *  Selenium RemoteWebDriver abstraction layer using the 'wd' npm pkg
 */

(function() {
  var Jeeves, LONG_INTERVAL, LONG_TIMEOUT, SHORT_INTERVAL, SHORT_TIMEOUT, asserters, async, logger, webdriver, _, _elFuncSuffix, _elementFuncTypes, _ref, _shimLevels,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  webdriver = require('wd');

  asserters = webdriver.asserters;

  async = require('async');

  _ = require('lodash');

  _ref = require('./logger'), logger = _ref.logger, _shimLevels = _ref._shimLevels;

  SHORT_TIMEOUT = 8000;

  LONG_TIMEOUT = 16000;

  SHORT_INTERVAL = 200;

  LONG_INTERVAL = 500;

  module.exports = Jeeves = (function() {
    Jeeves.prototype.SPECIAL_KEYS = webdriver.SPECIAL_KEYS;

    Jeeves.prototype.MOUSE_KEYS = {
      'left': 0,
      'middle': 1,
      'right': 2
    };

    Jeeves.prototype._utils = {
      enableWdLogs: function(driver) {
        driver.on('status', function(info) {
          return logger.warn("wd_status << " + info);
        });
        return driver.on('command', function(method, callPath, data) {
          var _ref1;
          if (!/CALL|RESPONSE/i.test(method)) {
            return;
          }
          if (/\/file$/.test(callPath) && ((data != null ? data.file : void 0) != null)) {
            data = JSON.stringify(data.file).substr(0, 50) + '...';
          }
          if (/takeScreenshot/.test(callPath)) {
            data = ((_ref1 = JSON.stringify(data)) != null ? _ref1.substr(0, 50) : void 0) + '...';
          }
          return logger.debug("wd_cmd >> " + method + " " + callPath + " with data: " + (data || 'NO_DATA'));
        });
      }
    };


    /**
     * @param  {Object}  driver                 an instance of the wd.promiseChainRemote
     * @param  {Object}  options                configuration settings
     * @param  {String}  options.screenshotDir  Custom folder path where screenshots will be saved
     * @param  {Object}  options.logger         Custom logger
     * @param  {Boolean} options.wdLogging      Flag to enable wd's native logging.
     * @param  {Object}  options.wdConfig       Options to pass along to the wd. See https://github.com/admc/wd#named-parameters
     * @param  {Object}  options.wdCapabilities Options used to initialize the webdriver.
     *                                            See https://code.google.com/p/selenium/wiki/DesiredCapabilities
     * @param  {Number} options.shortTimeout   Override in milliseconds of the default short timeout
     * @param  {Number} options.longTimeout    Override in milliseconds of the default long timeout
     * @return {undefined}
     */

    function Jeeves() {
      var driver, options, wd_config, _i, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      driver = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), options = arguments[_i++];
      if (options == null) {
        options = {};
      }
      this.waitForInnerHtmlByCss = __bind(this.waitForInnerHtmlByCss, this);
      this.clickElement = __bind(this.clickElement, this);
      wd_config = (_ref1 = options.wdConfig) != null ? _ref1 : {};
      this._wd_capabilites = (_ref2 = options.wdCapabilities) != null ? _ref2 : {
        browserName: 'chrome'
      };
      this.driver = (_ref3 = driver.shift()) != null ? _ref3 : null;
      if (this.driver == null) {
        this.driver = new webdriver.promiseChainRemote(wd_config);
      }
      if (options.wdLogging) {
        this._utils.enableWdLogs(this.driver);
      }
      webdriver.addAsyncMethod('screenshot', (function(_this) {
        return function(subdir, filename, cb) {
          return _this.takeScreenshot(subdir, filename, cb);
        };
      })(this));
      if (options.logger != null) {
        logger = _shimLevels(options.logger);
      }
      this._screenshotDir = (_ref4 = options.screenshotDir) != null ? _ref4 : "" + (process.cwd()) + "/test-results/screenshots";
      SHORT_TIMEOUT = (_ref5 = options.shortTimeout) != null ? _ref5 : SHORT_TIMEOUT;
      LONG_TIMEOUT = (_ref6 = options.longTimeout) != null ? _ref6 : LONG_TIMEOUT;
      return;
    }

    Jeeves.prototype.init = function(done) {
      return this.driver.init(this._wd_capabilites, (function(_this) {
        return function(error, driverSessionId) {
          var _ref1;
          if (error) {
            logger.error("webdriver init error:", (_ref1 = error.stack) != null ? _ref1 : error);
            return done(error);
          }
          logger.test("webdriver created & initialized.");
          logger.warn("webdriver sessionId:", driverSessionId);
          return done();
        };
      })(this));
    };


    /*
     *   Extension to `async.series`, run a named series flow (key:fn style)
     *   with optional `beforeEach()` & `afterEach()` callbacks,
     *   each being passed (name, fn).
     *   useful for logging async flows in tests.
     *   @todo: move to jeeves utils
     */

    Jeeves.prototype.namedSteps = function(tasks, doneCallback, beforeEach, afterEach) {
      var taskFn, taskName, _fn;
      if (_.isArray(tasks)) {
        throw new Error("asyncSeriesTap only works with a named stack");
      }
      if (beforeEach == null) {
        beforeEach = function(fnName) {
          return logger.test("-- " + fnName);
        };
      }
      _fn = function(taskName, taskFn) {
        return tasks[taskName] = function(next) {
          if (typeof beforeEach === "function") {
            beforeEach(taskName, taskFn);
          }
          return taskFn(function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            if (typeof afterEach === "function") {
              afterEach(taskName, taskFn);
            }
            return next.apply(this, args);
          });
        };
      };
      for (taskName in tasks) {
        taskFn = tasks[taskName];
        _fn(taskName, taskFn);
      }
      return async.series(tasks, doneCallback);
    };

    Jeeves.prototype.getBrowser = function(done) {
      logger.test('@getBrowser');
      return this.driver.getCurrentBrowser(done);
    };

    Jeeves.prototype.explicitWait = function(seconds, done) {
      logger.test('@explicitWait', seconds);
      return setTimeout(done, 1000 * seconds);
    };

    Jeeves.prototype.stopBrowser = function(done) {
      var clientScript;
      logger.test('@stopBrowser');
      clientScript = function() {
        if (typeof window.stop === "function") {
          window.stop();
        }
        return typeof document.execCommand === "function" ? document.execCommand("Stop", false) : void 0;
      };
      return this.executeClientScript(clientScript, function(error) {
        if (error) {
          logger.error('Stopping browser failed', error);
        }
        return done();
      });
    };

    Jeeves.prototype.loadPage = function(url, done) {
      logger.test('@loadPage', url);
      if (!((url != null ? url.length : void 0) && !!url.toLowerCase().match(/^http/))) {
        return done(new Error("Need full URL to loadPage, but got " + url));
      }
      logger.test('Stopping browser before loading page.');
      return this.stopBrowser((function(_this) {
        return function(error) {
          if (error) {
            error.message = "Error stopping browser: " + error.message;
            return done(error);
          }
          logger.test("Browser is stopped. Attempting to load url: " + url);
          return _this.driver.get(url).nodeify(function(error) {
            logger.test("Tried to load " + url, error || 'no error');
            return done(error);
          });
        };
      })(this));
    };

    Jeeves.prototype.loadPageAndWait = function(url, done) {
      logger.test('@loadPageAndWait', url);
      return this.loadPage(url, (function(_this) {
        return function(error) {
          var _ref1;
          if (error) {
            logger.error("Error loading page: " + ((_ref1 = error.message) != null ? _ref1 : error));
            return done(error);
          }
          return _this.waitForUrlToChange(url, true, function(error, actualUrl) {
            logger.test('@loadPageAndWait got', (error ? "Error: " + error.message : actualUrl));
            return done(error, actualUrl);
          });
        };
      })(this));
    };

    Jeeves.prototype.getCurrentUrl = function(done) {
      logger.test('@getCurrentUrl');
      return this.driver.url().nodeify(function(error, url) {
        logger.test("-- current url is " + url);
        return done(error, url);
      });
    };

    Jeeves.prototype.navBack = function(done) {
      logger.test('@navBack');
      return this.driver.back().nodeify(done);
    };

    Jeeves.prototype.navForward = function(done) {
      logger.test('@navForward');
      return this.driver.forward().nodeify(done);
    };

    Jeeves.prototype.refreshPage = function(done) {
      logger.test('@refreshPage');
      return this.driver.refresh().nodeify(done);
    };

    Jeeves.prototype.getAllCookies = function(done) {
      logger.test('@getAllCookies');
      return this.driver.allCookies().nodeify(function(error, cookies) {
        logger.test("All cookies obtained(" + (error != null ? error : 'no error') + "):", cookies);
        return done(error, cookies);
      });
    };

    Jeeves.prototype.setCookie = function(cookie, done) {
      logger.test('@setCookie');
      return this.driver.setCookie(cookie).nodeify(function(error) {
        logger.test("Cookie set. " + (error != null ? error : 'no error'));
        return done(error);
      });
    };

    Jeeves.prototype.deleteAllCookies = function(done) {
      logger.test('@deleteAllCookies');
      return this.driver.deleteAllCookies().nodeify(function(error) {
        logger.test("All cookies deleted! " + (error != null ? error : 'no error'));
        return done(error);
      });
    };

    Jeeves.prototype.deleteCookie = function(cookieName, done) {
      logger.test('@deleteCookie');
      return this.driver.deleteCookie(cookieName).nodeify(function(error) {
        logger.test("Cookie deleted! " + (error != null ? error : 'no error'));
        return done(error);
      });
    };

    Jeeves.prototype.getPageTitle = function(done) {
      logger.test('@getPageTitle');
      return this.driver.title().nodeify(function(error, title) {
        logger.test('title obtained:', title);
        return done(error, title);
      });
    };

    Jeeves.prototype.getWindowHandles = function(done) {
      logger.test('@getWindowHandles');
      return this.driver.windowHandles().nodeify(done);
    };

    Jeeves.prototype.getCurrentWindowHandle = function(done) {
      logger.test('@getCurrentWindowHandle');
      return this.driver.windowHandle().nodeify(done);
    };

    Jeeves.prototype.switchToWindow = function(windowName, done) {
      logger.test("@switchToWindow named: " + windowName);
      return this.driver.window(windowName).nodeify(done);
    };


    /*
     *  JS alert box management
     */

    Jeeves.prototype.acceptAlert = function(done) {
      logger.test('@acceptAlert');
      return this.driver.acceptAlert().nodeify(done);
    };

    Jeeves.prototype.dismissAlert = function(done) {
      logger.test('@dismissAlert');
      return this.driver.dismissAlert().nodeify(done);
    };

    Jeeves.prototype.getAlertText = function(done) {
      logger.test('@getAlertText');
      return this.driver.alertText().nodeify(done);
    };

    Jeeves.prototype.sendAlertKeys = function(keys, done) {
      logger.test("@sendAlertKeys " + keys);
      return this.driver.alertKeys(keys).nodeify(done);
    };

    Jeeves.prototype.quit = function(done) {
      logger.test('@quit');
      return this.driver.quit().nodeify(done);
    };


    /*
     * @done callback gets (error, source)
     */

    Jeeves.prototype.getFullBody = function(done) {
      logger.test('@getFullBody');
      return this.driver.source().nodeify(done);
    };

    Jeeves.prototype.takeScreenshot = function(subdir, filename, done) {
      logger.test('@takeScreenshot');
      return this.driver.takeScreenshot().nodeify((function(_this) {
        return function(error, imgBuffer) {
          var directory, ensureDir, filePath, fs;
          if (error) {
            return done(error);
          }
          ensureDir = require('ensureDir');
          fs = require('fs');
          directory = "" + _this._screenshotDir + "/" + subdir;
          filePath = "" + directory + "/" + filename + ".png";
          return ensureDir(directory, '0755', function(error) {
            if (error) {
              return done(error);
            }
            return fs.writeFile(filePath, imgBuffer, 'base64', function(error) {
              if (error) {
                return done(error);
              } else {
                logger.test("Saved screenshot to " + filePath);
                return done(null, filePath);
              }
            });
          });
        };
      })(this));
    };


    /*
     *  *SYNCHRONOUSLY* run a script on the client.
     *  @fn function to run in client scope.
     *    - fn should take same params as `params` here.
     *  @params... vars to pass to client scope.
     *  @done callback. gets results.
     *
     *  IMPT:
     *  - if `params` includes a hash w/ an inline function,
     *    the fn will be passed as a string, not a function (so it won't work).
     *  - return something short & simple! (coffeescript returns the last line,
     *    if it's something huge it'll overload the callstack)
     */

    Jeeves.prototype.executeClientScript = function() {
      var done, fn, params, _i;
      fn = arguments[0], params = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
      logger.test('@executeClientScript');
      return this.driver.execute(fn, params, (function(_this) {
        return function(error, results) {
          logger.debug("@executeClientScript results: " + (JSON.stringify(results)) + "\n");
          if (error) {
            return done(error);
          } else if (_.isString(results) && /^error/i.test(results)) {
            return done(new Error(results));
          } else {
            return done(null, results);
          }
        };
      })(this));
    };


    /*
     *  *ASYNCHRONOUSLY* run a script on the client.
     *  same as executeClientScript, but `fn` needs to include a callback
     *  and code execution will continue
     *    - order: fn(params..., callback)
     */

    Jeeves.prototype.executeAsyncClientScript = function() {
      var done, fn, params, _i;
      fn = arguments[0], params = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
      logger.test('@executeAsyncClientScript');
      return this.driver.executeAsync(fn, params, (function(_this) {
        return function(error, results) {
          logger.debug("@executeAsyncClientScript results: " + (JSON.stringify(results)) + "\n");
          if (error) {
            return done(error);
          } else if (_.isString(results) && /^error/i.test(results)) {
            return done(new Error(results));
          } else {
            return done(null, results);
          }
        };
      })(this));
    };

    Jeeves.prototype.compareElements = function(elem1, elem2, done) {
      logger.test('@compareElements');
      return this.driver.equalsElement(elem1, elem2).nodeify(done);
    };

    Jeeves.prototype.phantomUploadFile = function(selector, filePath, done) {
      logger.test("@phantomUploadFile using: " + selector + "\nFile: " + filePath);
      if (this.driver.phantomUploadFile != null) {
        return this.driver.phantomUploadFile(selector, filePath).nodeify(done);
      } else {
        return done(new Error('Phantom file uploads are not supported by your version of WD.'));
      }
    };

    Jeeves.prototype.uploadFile = function(filePath, done) {
      logger.test("@uploadFile " + filePath);
      return this.driver.uploadFile(filePath).nodeify(done);
    };

    Jeeves.prototype.jsMouseClick = function() {
      var b, button, cssSelector, done, jqueryClick, key, _i;
      cssSelector = arguments[0], button = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
      key = button.shift() || 'left';
      b = this.MOUSE_KEYS[key];
      logger.test("@jsMouseClick with button: " + key);
      jqueryClick = function() {
        return $(arguments[0])[0].click();
      };
      return this.executeClientScript(jqueryClick, cssSelector, done);
    };

    Jeeves.prototype.mouseClick = function() {
      var b, button, done, key, _i;
      button = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), done = arguments[_i++];
      key = button.shift() || 'left';
      b = this.MOUSE_KEYS[key];
      logger.test("@mouseClick with button: " + key);
      return this.driver.click(b).nodeify(done);
    };

    Jeeves.prototype.mouseDownUp = function() {
      var b, button, done, key, _i;
      button = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), done = arguments[_i++];
      key = button.shift() || 'left';
      b = this.MOUSE_KEYS[key];
      logger.test("@mouseDownUp with button: " + key);
      return this.driver.buttonDown(b).buttonUp(b).nodeify(done);
    };

    Jeeves.prototype.mouseMove = function(x, y, done) {
      logger.test("@mouseMove to x:" + x + ", y:" + y);
      return this.driver.moveTo(null, x, y).nodeify(done);
    };

    Jeeves.prototype.clearElement = function(elem, done) {
      logger.test('@clearElement', elem);
      return typeof elem.clear === "function" ? elem.clear().nodeify(done) : void 0;
    };

    Jeeves.prototype.clickElement = function(elem, done) {
      logger.test('@clickElement', elem);
      return typeof elem.click === "function" ? elem.click().nodeify(done) : void 0;
    };

    Jeeves.prototype.typeKeys = function(keys, done) {
      logger.test('@typeKeys', keys);
      return this.driver.keys(keys).nodeify(done);
    };

    Jeeves.prototype.forceElementVisible = function(cssSelector, done) {
      var clientMakeVisible;
      logger.test("@forceElementVisible " + cssSelector);
      clientMakeVisible = function(cssPath) {
        var el, els, _i, _len;
        $(cssPath).show();
        els = $(cssPath);
        for (_i = 0, _len = els.length; _i < _len; _i++) {
          el = els[_i];
          el.style.visibility = 'visible';
          el.style.height = '1px';
          el.style.width = '1px';
          el.style.opacity = 1;
        }
      };
      return this.executeClientScript(clientMakeVisible, cssSelector, done);
    };

    Jeeves.prototype.hasClass = function(elem, className, done) {
      logger.test("@hasClass(" + elem + ", " + className + ")");
      return elem.getAttribute('class').nodeify(function(error, value) {
        var classes;
        if (error) {
          return done(error);
        }
        classes = value.split(' ');
        logger.test("** classNames on " + elem + ": " + classes);
        if (__indexOf.call(classes, className) >= 0) {
          logger.warn('elem has class!');
          return done(null, true);
        }
        return done(null, false);
      });
    };

    Jeeves.prototype.isChecked = function(elem, done) {
      logger.test('@isChecked');
      return this.getAttributeValue(elem, 'checked', done);
    };

    Jeeves.prototype.isSelected = function(elem, done) {
      logger.test('@isSelected');
      return typeof elem.isSelected === "function" ? elem.isSelected().nodeify(done) : void 0;
    };

    Jeeves.prototype.isDisplayed = function(elem, done) {
      logger.test('@isDisplayed');
      return typeof elem.isDisplayed === "function" ? elem.isDisplayed().nodeify(done) : void 0;
    };

    Jeeves.prototype.isTextPresent = function(elem, searchText, done) {
      logger.test("@isTextPresent {elem: " + elem + ", searchText: " + searchText + "}");
      return typeof elem.textPresent === "function" ? elem.textPresent(searchText).nodeify(function(error, textFound) {
        logger.test("Text found: " + textFound);
        return done(error, textFound);
      }) : void 0;
    };

    Jeeves.prototype.checkForElemWithProperText = function(elemCssPath, elemText, done) {
      var elem;
      logger.test("@checkForElemWithProperText params:{elemCssPath: " + elemCssPath + ", elemText: " + elemText + "}");
      elem = null;
      return this.namedSteps({
        getElementByCss: (function(_this) {
          return function(next) {
            return _this.findElementOrNullByCss(elemCssPath, function(error, _elem) {
              elem = _elem;
              return next(error);
            });
          };
        })(this),
        checkForElement: (function(_this) {
          return function(next) {
            return next(null, elem != null);
          };
        })(this),
        checkForTextByCss: (function(_this) {
          return function(next) {
            if (elem == null) {
              logger.test('Element did not exist. Can\'t check for text.');
              return next();
            } else {
              return _this.isTextPresent(elem, elemText, next);
            }
          };
        })(this)
      }, function(error, results) {
        var _result;
        logger.test('@checkForElemWithProperText results:', results);
        _result = (results != null ? results.checkForElement : void 0) && (results != null ? results.checkForTextByCss : void 0);
        if (_result != null) {
          return done(null, _result);
        } else {
          return done(error, _result);
        }
      });
    };

    Jeeves.prototype.getActiveElement = function(done) {
      logger.test('@getActiveElement');
      return this.driver.active().nodeify(done);
    };

    Jeeves.prototype.getAttributeValue = function(elem, attrName, done) {
      logger.test("@getAttributeValue " + attrName);
      return typeof elem.getAttribute === "function" ? elem.getAttribute(attrName).nodeify(done) : void 0;
    };

    Jeeves.prototype.getElementLocation = function(elem, done) {
      logger.test('@getElementLocation');
      return typeof elem.getLocation === "function" ? elem.getLocation().nodeify(done) : void 0;
    };

    Jeeves.prototype.getComputedCss = function(elem, cssProperty, done) {
      logger.test('@getComputedCss');
      return typeof elem.getComputedCss === "function" ? elem.getComputedCss(cssProperty).nodeify(done) : void 0;
    };

    Jeeves.prototype.getTagName = function(elem, done) {
      logger.test('@getTagName');
      return typeof elem.getTagName === "function" ? elem.getTagName().nodeify(done) : void 0;
    };

    Jeeves.prototype.getText = function(elem, done) {
      logger.test('@getText on elem');
      return typeof elem.text === "function" ? elem.text().nodeify(done) : void 0;
    };

    Jeeves.prototype.getInnerHtmlByCss = function(cssSelector, done) {
      var clientInnerHtml;
      logger.test("@getInnerHtmlByCss on " + cssSelector);
      clientInnerHtml = function() {
        return $(arguments[0])[0].innerHTML;
      };
      return this.executeClientScript(clientInnerHtml, cssSelector, done);
    };

    Jeeves.prototype.getCssCount = function(cssSelector, done) {
      logger.test('@getCssCount');
      return async.waterfall([
        (function(_this) {
          return function(next) {
            return _this.getElementsByCss(cssSelector, next);
          };
        })(this), (function(_this) {
          return function(elems, next) {
            return next(null, elems.length);
          };
        })(this)
      ], function(error, count) {
        logger.test("Count is: " + count);
        return done(error, count);
      });
    };

    Jeeves.prototype.getTextOfElementsByCss = function(cssSelector, done) {
      var clientGetTextFromElems;
      logger.test("@getTextOfElementsByCss " + cssSelector);
      clientGetTextFromElems = function(cssPath) {
        var innards;
        innards = [];
        $(cssPath).each(function(i, el) {
          return innards.push($(el).text());
        });
        return innards;
      };
      return this.executeClientScript(clientGetTextFromElems, cssSelector, done);
    };


    /*
     *  Generic `waitFor` method, can be used to wait for:
     *     test conditions or browser conditions
     *  wait for a `checkFn` callback to return true.
     *
     *  @checkFn(): should return (null,true) when passes.
     *    - can return error on error. null,false is ignored.
     *  @options
     *    @interval default 100ms.
     *    @timeout total time to wait. default 3 seconds.
     *    @msg message on timeout error
     */

    Jeeves.prototype.waitForSomething = function(checkFn, options, done) {
      var checkCount, finish, finishTimeout, startTime, _finished;
      logger.test('@waitForSomething');
      _.defaults(options, {
        interval: 500,
        timeout: 3000,
        msg: '[something]'
      });
      _finished = false;
      checkCount = 0;
      finish = _.once(function(error, result) {
        _finished = true;
        clearTimeout(finishTimeout);
        logger.test("@waitForSomething finished after " + checkCount + " checks. Took " + (Date.now() - startTime) + "ms");
        if (error) {
          return done(error);
        } else {
          return done();
        }
      });
      finishTimeout = setTimeout(function() {
        return finish(new Error("Timed out after " + options.timeout + "ms (" + checkCount + " checks): " + options.msg));
      }, options.timeout);
      startTime = Date.now();
      return async.whilst(function() {
        return _finished === false;
      }, function(doneCheck) {
        var checkIsDone, intervalHasPassed;
        checkCount++;
        doneCheck = _.once(doneCheck);
        intervalHasPassed = false;
        checkIsDone = false;
        setTimeout(function() {
          intervalHasPassed = true;
          if (checkIsDone) {
            return doneCheck();
          }
        }, options.interval);
        return checkFn(function(error, result) {
          checkIsDone = true;
          if (error || result === true) {
            finish(error, result);
            return doneCheck();
          } else {
            if (intervalHasPassed) {
              return doneCheck();
            }
          }
        });
      }, function() {});
    };


    /*
     *  @expectedUrl string or regex
     *  @matches - should it match or not
     *  @options - options object for custom timeout & interval
     *  @done callback, gets (error, url).
     */

    Jeeves.prototype.waitForUrlToChange = function() {
      var checkUrl, done, expectedUrl, matches, options, toFrom, _i;
      expectedUrl = arguments[0], matches = arguments[1], options = 4 <= arguments.length ? __slice.call(arguments, 2, _i = arguments.length - 1) : (_i = 2, []), done = arguments[_i++];
      if (matches == null) {
        matches = true;
      }
      toFrom = matches ? 'to' : 'from';
      logger.test("@waitForUrlToChange " + toFrom + " " + expectedUrl);
      options = options.shift() || {};
      _.defaults(options, {
        timeout: LONG_TIMEOUT,
        interval: SHORT_INTERVAL
      });
      checkUrl = (function(_this) {
        return function(callback) {
          return _this.getCurrentUrl(function(error, newUrl) {
            var check;
            if (error) {
              return callback(error);
            }
            if (_.isString(expectedUrl)) {
              check = (newUrl === expectedUrl) === matches;
            } else {
              check = (!!newUrl.match(expectedUrl)) === matches;
            }
            return callback(null, check);
          });
        };
      })(this);
      return this.waitForSomething(checkUrl, {
        msg: "URL did not change  " + toFrom + " " + expectedUrl,
        timeout: options.timeout,
        interval: options.interval
      }, (function(_this) {
        return function(error) {
          var _ref1;
          logger.test('-- waitForUrlToChange done. Attempting to get url', [expectedUrl, (_ref1 = error != null ? error.message : void 0) != null ? _ref1 : 'no error']);
          if (error) {
            return done(error);
          }
          return _this.getCurrentUrl(done);
        };
      })(this));
    };


    /*
     * wait for an element to have an attribute
     * @cssSelector the path to the element
     * @attr the attribute that you're expecting the evelope to have
     * @attrValue [optional] set if your waiting for the attribute to have a specific value
     * @done callback gets the el. (no reason to run 2nd call to get it when we know it exists.)
     */

    Jeeves.prototype.waitForAttributeByCss = function(cssSelector, attr, attrValue, done) {
      var elemAttributeValue;
      logger.test("@waitForAttributeByCss {cssSelector: " + cssSelector + "\nattr: " + attr + "\nattrValue: " + attrValue + "}");
      elemAttributeValue = null;
      return this.waitForSomething((function(_this) {
        return function(callback) {
          return _this.getAttributeValueByCss(cssSelector, attr, function(error, val) {
            if (error) {
              return callback(error);
            } else {
              if (val == null) {
                return callback(null, false);
              }
              if ((attrValue != null) && val !== attrValue) {
                return callback(null, false);
              }
              elemAttributeValue = val;
              return callback(null, true);
            }
          });
        };
      })(this), {
        msg: "'" + attr + "' -- not found",
        timeout: SHORT_TIMEOUT,
        interval: LONG_INTERVAL
      }, function(error) {
        if (error) {
          return done(error);
        }
        logger.test("element '" + cssSelector + "' has attribute " + attr + " with value " + elemAttributeValue);
        return done(null, elemAttributeValue);
      });
    };


    /*
     * this method has benefit when waiting for text that isn't visible
     */

    Jeeves.prototype.waitForInnerHtmlByCss = function() {
      var done, htmlToReturn, options, regex, selectorValue, _i;
      selectorValue = arguments[0], regex = arguments[1], options = 4 <= arguments.length ? __slice.call(arguments, 2, _i = arguments.length - 1) : (_i = 2, []), done = arguments[_i++];
      logger.test("@waitForInnerHtmlByCss using { selectorValue: " + selectorValue + "\n regex: " + regex + " }");
      done = _.once(done);
      options = options.shift() || {};
      _.defaults(options, {
        timeout: 10000,
        interval: 100
      });
      htmlToReturn = null;
      return this.waitForElementByCss(selectorValue, options, (function(_this) {
        return function(error) {
          if (error) {
            return done(error);
          }
          return _this.waitForSomething(function(callback) {
            return _this.getInnerHtmlByCss(selectorValue, function(error, html) {
              logger.test('    html is: ' + (html != null ? html : '[empty]'));
              if (error) {
                return callback(error);
              }
              htmlToReturn = html;
              if (!html) {
                return callback(null, false);
              } else {
                return callback(null, !!html.match(regex));
              }
            });
          }, {
            msg: "'" + regex + "' -- not found. Last html found: " + htmlToReturn,
            timeout: options.timeout,
            interval: options.interval
          }, function(error) {
            logger.test("done waiting for regex to match " + (error != null ? error : 'no error'));
            if (error) {
              return done(error);
            }
            return done(null, htmlToReturn);
          });
        };
      })(this));
    };


    /* waitForCondition expected params
     * @conditionExpr: condition expression, should return a boolean
     * @timeout: timeout (optional, default: 5 sec)
     * @pollFreq: polling frequency (optional, default: 300ms)
     */

    Jeeves.prototype.waitForCondition = function(conditionExpr, timeout, pollFreq, done) {
      var condtion;
      if (timeout == null) {
        timeout = 5;
      }
      if (pollFreq == null) {
        pollFreq = 300;
      }
      logger.test('@waitForCondition');
      timeout = timeout * 1000;
      condtion = asserters.jsCondition(conditionExpr, true);
      return this.driver.waitFor(condtion, timeout, pollFreq).nodeify(done);
    };

    Jeeves.prototype.waitForConditionInBrowser = function(conditionExpr, timeout, pollFreq, done) {
      if (timeout == null) {
        timeout = 5;
      }
      if (pollFreq == null) {
        pollFreq = 300;
      }
      logger.test('@waitForConditionInBrowser');
      timeout = timeout * 1000;
      return this.driver.waitForConditionInBrowser(conditionExpr, timeout, pollFreq).nodeify(done);
    };


    /*
     * NOTE: this method is working but needs tests
     * @startElement - Element to move
     * @endpointPosition - takes in an object with x/y attributes - for example: {x: 20, y: 230}
     * @endpointElement - wd's documentation says this is optional, but that's not true
     *                   it actually bases the endpointPosition off the position of this element
     */

    Jeeves.prototype.dragElement = function(startElement, endpointPosition, endpointElement, done) {
      logger.test("@dragElement ", endpointPosition);
      return this.driver.moveTo(startElement, void 0, void 0).buttonDown(0).moveTo(endpointElement, 205, -5).moveTo(endpointElement, endpointPosition.x, endpointPosition.y).buttonUp(0).nodeify(done);
    };


    /*
     * Similar to `dragElement`, but simulates a mouse click to select then another to drop
     */

    Jeeves.prototype.clickAndStamp = function(startElement, endpointPosition, endpointElement, done) {
      logger.test("@clickAndStamp ", endpointPosition);
      return this.driver.moveTo(startElement, void 0, void 0).click(0).moveTo(endpointElement, 205, -5).moveTo(endpointElement, endpointPosition.x, endpointPosition.y).click(0).nodeify(done);
    };

    Jeeves.prototype.ieClickAndStamp = function(startElement, endpointPosition, endpointElement, done) {};

    Jeeves.prototype.ieDragAndDrop = function(startElement, endpointPosition, endpointElement, done) {
      var elemId, elemPos, endPos, pageX, pageY;
      logger.test("@ieDragAndDrop ", endpointPosition);
      elemPos = pageX = pageY = elemId = null;
      endPos = _.defaults(endpointPosition);
      return this.namedSteps({
        endElemPost: (function(_this) {
          return function(next) {
            return _this.getElementLocation(endpointElement, function(error, pos) {
              endPos.x = endPos.x + pos.x;
              endPos.y = endPos.y + pos.y;
              return next(error);
            });
          };
        })(this),
        elemPosition: (function(_this) {
          return function(next) {
            return _this.getElementLocation(startElement, function(error, pos) {
              elemPos = pos;
              return next(error);
            });
          };
        })(this),
        elemSize: (function(_this) {
          return function(next) {
            return startElement.getSize().nodeify(function(error, elemSize) {
              pageX = elemPos.x + ~~(elemSize.width / 2);
              pageY = elemPos.y + ~~(elemSize.height / 2);
              return next(error);
            });
          };
        })(this),
        elemId: (function(_this) {
          return function(next) {
            return _this.getAttributeValue(startElement, 'id', function(error, _elemId) {
              elemId = _elemId;
              return next(error);
            });
          };
        })(this),
        jsSimulation: (function(_this) {
          return function(next) {
            var className, wtfIe;
            className = 'title';
            wtfIe = "var mousedown=document.createEvent(\"MouseEvent\"),mouseup=document.createEvent(\"MouseEvent\"),elem=document.getElementById(\"" + elemId + "\"),result=[],elems=elem.getElementsByTagName(\"*\"),k=0,j=0,i,interval;for(i in elems){if((\" \"+elems[i].className+\" \").indexOf(\" " + className + " \")>-1){result.push(elems[i]);}}mousedown.initMouseEvent(\"mousedown\",true,true,window,0,0,0," + pageX + "," + pageY + ",0,0,0,0,0,null);result[0].dispatchEvent(mousedown);interval=setInterval(function(){if(k!==" + endPos.x + "){k++;};if(j!==" + endPos.y + "){j++;};iter(k,j);if(k===" + endPos.x + "+1&&j===" + endPos.y + "+1){clearInterval(interval);mouseup.initMouseEvent(\"mouseup\",true,true,window,0," + pageX + "+k," + pageY + "+j," + pageX + "+k," + pageY + "+j,0,0,0,0,0,null);result[0].dispatchEvent(mouseup);}},100);function iter(_x,_y){var mousemove=document.createEvent(\"MouseEvent\");mousemove.initMouseEvent(\"mousemove\",true,true,window,0,0,0," + pageX + "+_x," + pageY + "+_y,0,0,0,0,0,null);result[0].dispatchEvent(mousemove);}";
            return _this.driver.safeExecute(wtfIe, next);
          };
        })(this)
      }, done);
    };

    return Jeeves;

  })();

  Jeeves.prototype._utils._elementFuncTypes = _elementFuncTypes = ['class name', 'css selector', 'id', 'name', 'link text', 'partial link text', 'tag name', 'xpath', 'css'];

  Jeeves.prototype._utils._elFuncSuffix = _elFuncSuffix = function(type) {
    var res;
    res = (" by " + type).replace(/(\s[a-z])/g, function($1) {
      return $1.toUpperCase().replace(" ", "");
    });
    return res.replace("Xpath", "XPath");
  };

  _.each(_elementFuncTypes, function(type) {

    /*
     * Single Find
     *   @getElementByClassName = (selectorValue, done) -> done(error, elem)
     *   @getElementByCssSelector = (selectorValue, done) -> done(error, elem)
     *   @getElementById = (selectorValue, done) -> done(error, elem)
     *   @getElementByName = (selectorValue, done) -> done(error, elem)
     *   @getElementByLinkText = (selectorValue, done) -> done(error, elem)
     *   @getElementByPartialLinkText = (selectorValue, done) -> done(error, elem)
     *   @getElementByTagName = (selectorValue, done) -> done(error, elem)
     *   @getElementByXPath = (selectorValue, done) -> done(error, elem)
     *   @getElementByCss = (selectorValue, done) -> done(error, elem)
     */
    Jeeves.prototype['getElement' + _elFuncSuffix(type)] = function(selectorValue, done) {
      logger.test("@getElement" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this.driver["element" + (_elFuncSuffix(type))](selectorValue).nodeify(function(error, elem) {
        logger.test("got the elem: " + elem);
        return done(error, elem);
      });
    };

    /*
     * Find single Elem IfExists
     *   @getElemIfExistsByClassName = (selectorValue, done) -> done(error, elemOrUndefined)
     *   @getElemIfExistsByCssSelector = (selectorValue, done) -> done(error, elemOrUndefined)
     *   @getElemIfExistsById = (selectorValue, done) -> done(error, elemOrUndefined)
     *   @getElemIfExistsByName = (selectorValue, done) -> done(error, elemOrUndefined)
     *   @getElemIfExistsByLinkText = (selectorValue, done) -> done(error, elemOrUndefined)
     *   @getElemIfExistsByPartialLinkText = (selectorValue, done) -> done(error, elemOrUndefined)
     *   @getElemIfExistsByTagName = (selectorValue, done) -> done(error, elemOrUndefined)
     *   @getElemIfExistsByXPath = (selectorValue, done) -> done(error, elemOrUndefined)
     *   @getElemIfExistsByCss = (selectorValue, done) -> done(error, elemOrUndefined)
     */
    Jeeves.prototype['getElemIfExists' + _elFuncSuffix(type)] = function(selectorValue, done) {
      logger.test("@" + ("element" + (_elFuncSuffix(type)) + "IfExists") + " using selectorValue: " + selectorValue);
      return this.driver["element" + (_elFuncSuffix(type)) + "IfExists"](selectorValue).nodeify(function(error, elem) {
        logger.test("got the elem: " + elem);
        return done(error, elem);
      });
    };

    /*
     * Multi Find
     *   @getElementsByClassName = (selectorValue, done) -> done(error, elems)
     *   @getElementsByCssSelector = (selectorValue, done) -> done(error, elems)
     *   @getElementsById = (selectorValue, done) -> done(error, elems)
     *   @getElementsByName = (selectorValue, done) -> done(error, elems)
     *   @getElementsByLinkText = (selectorValue, done) -> done(error, elems)
     *   @getElementsByPartialLinkText = (selectorValue, done) -> done(error, elems)
     *   @getElementsByTagName = (selectorValue, done) -> done(error, elems)
     *   @getElementsByXPath = (selectorValue, done) -> done(error, elems)
     *   @getElementsByCss = (selectorValue, done) -> done(error, elems)
     */
    Jeeves.prototype['getElements' + _elFuncSuffix(type)] = function(selectorValue, done) {
      logger.test("@getElements" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this.driver["elements" + (_elFuncSuffix(type))](selectorValue).nodeify(function(error, elems) {
        logger.test("got the elems: " + elems);
        return done(error, elems);
      });
    };

    /*
     * Find ElemOrNull
     *   @findElementOrNullByClassName = (selectorValue, done) -> done(error, elemOrNull)
     *   @findElementOrNullByCssSelector = (selectorValue, done) -> done(error, elemOrNull)
     *   @findElementOrNullById = (selectorValue, done) -> done(error, elemOrNull)
     *   @findElementOrNullByName = (selectorValue, done) -> done(error, elemOrNull)
     *   @findElementOrNullByLinkText = (selectorValue, done) -> done(error, elemOrNull)
     *   @findElementOrNullByPartialLinkText = (selectorValue, done) -> done(error, elemOrNull)
     *   @findElementOrNullByTagName = (selectorValue, done) -> done(error, elemOrNull)
     *   @findElementOrNullByXPath = (selectorValue, done) -> done(error, elemOrNull)
     *   @findElementOrNullByCss = (selectorValue, done) -> done(error, elemOrNull)
     */
    Jeeves.prototype['findElementOrNull' + _elFuncSuffix(type)] = function(selectorValue, done) {
      logger.test("@findElementOrNull" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this.driver["element" + (_elFuncSuffix(type)) + "OrNull"](selectorValue).nodeify(function(error, elem) {
        logger.test("got the elem?: " + elem);
        return done(error, elem);
      });
    };

    /*
     *   @getChildElementByClassName = (elem, selectorValue, done) -> done(error, elem)
     *   @getChildElementByCssSelector = (elem, selectorValue, done) -> done(error, elem)
     *   @getChildElementById = (elem, selectorValue, done) -> done(error, elem)
     *   @getChildElementByName = (elem, selectorValue, done) -> done(error, elem)
     *   @getChildElementByLinkText = (elem, selectorValue, done) -> done(error, elem)
     *   @getChildElementByPartialLinkText = (elem, selectorValue, done) -> done(error, elem)
     *   @getChildElementByTagName = (elem, selectorValue, done) -> done(error, elem)
     *   @getChildElementByXPath = (elem, selectorValue, done) -> done(error, elem)
     *   @getChildElementByCss = (elem, selectorValue, done) -> done(error, elem)
     */
    Jeeves.prototype['getChildElement' + _elFuncSuffix(type)] = function(elem, selectorValue, done) {
      logger.test("@getChildElement" + (_elFuncSuffix(type)) + " in parent " + (elem != null ? elem.value : void 0) + " using selector '" + selectorValue + "'");
      return elem["element" + (_elFuncSuffix(type))](selectorValue).nodeify(function(error, elem) {
        logger.test("got the child elem: " + elem);
        return done(error, elem);
      });
    };

    /*
     *   @getChildElementsByClassName = (elem, selectorValue, done) -> done(error, elems)
     *   @getChildElementsByCssSelector = (elem, selectorValue, done) -> done(error, elems)
     *   @getChildElementsById = (elem, selectorValue, done) -> done(error, elems)
     *   @getChildElementsByName = (elem, selectorValue, done) -> done(error, elems)
     *   @getChildElementsByLinkText = (elem, selectorValue, done) -> done(error, elems)
     *   @getChildElementsByPartialLinkText = (elem, selectorValue, done) -> done(error, elems)
     *   @getChildElementsByTagName = (elem, selectorValue, done) -> done(error, elems)
     *   @getChildElementsByXPath = (elem, selectorValue, done) -> done(error, elems)
     *   @getChildElementsByCss = (elem, selectorValue, done) -> done(error, elems)
     */
    Jeeves.prototype['getChildElements' + _elFuncSuffix(type)] = function(elem, selectorValue, done) {
      logger.test("@getChildElements" + (_elFuncSuffix(type)) + " in parent " + (elem != null ? elem.value : void 0) + " using selector '" + selectorValue + "'");
      return elem["elements" + (_elFuncSuffix(type))](selectorValue).nodeify(function(error, elems) {
        logger.test("got the elems: " + elems);
        return done(error, elems);
      });
    };

    /*
     *   @clickElementByClassName = (selectorValue, done) -> done(error)
     *   @clickElementByCssSelector = (selectorValue, done) -> done(error)
     *   @clickElementById = (selectorValue, done) -> done(error)
     *   @clickElementByName = (selectorValue, done) -> done(error)
     *   @clickElementByLinkText = (selectorValue, done) -> done(error)
     *   @clickElementByPartialLinkText = (selectorValue, done) -> done(error)
     *   @clickElementByTagName = (selectorValue, done) -> done(error)
     *   @clickElementByXPath = (selectorValue, done) -> done(error)
     *   @clickElementByCss = (selectorValue, done) -> done(error)
     */
    Jeeves.prototype['clickElement' + _elFuncSuffix(type)] = function(selectorValue, done) {
      logger.test("@clickElement" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this["getElement" + (_elFuncSuffix(type))](selectorValue, function(error, elem) {
        if (error) {
          return done(error);
        }
        logger.test('Element found! Attempting to click...');
        return elem.click().nodeify(done);
      });
    };

    /*
     *   @submitByClassName = (selectorValue, done) -> done(error)
     *   @submitByCssSelector = (selectorValue, done) -> done(error)
     *   @submitById = (selectorValue, done) -> done(error)
     *   @submitByName = (selectorValue, done) -> done(error)
     *   @submitByLinkText = (selectorValue, done) -> done(error)
     *   @submitByPartialLinkText = (selectorValue, done) -> done(error)
     *   @submitByTagName = (selectorValue, done) -> done(error)
     *   @submitByXPath = (selectorValue, done) -> done(error)
     *   @submitByCss = (selectorValue, done) -> done(error)
     */
    Jeeves.prototype['submit' + _elFuncSuffix(type)] = function(selectorValue, done) {
      logger.test("@submit" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this["getElement" + (_elFuncSuffix(type))](selectorValue, function(error, elem) {
        if (error) {
          return done(error);
        }
        logger.test('Element found! Attempting to submit form...');
        return elem.submit().nodeify(done);
      });
    };

    /*
     *   @sendTextToElementByClassName = (selectorValue, text, done) -> done(error)
     *   @sendTextToElementByCssSelector = (selectorValue, text, done) -> done(error)
     *   @sendTextToElementById = (selectorValue, text, done) -> done(error)
     *   @sendTextToElementByName = (selectorValue, text, done) -> done(error)
     *   @sendTextToElementByLinkText = (selectorValue, text, done) -> done(error)
     *   @sendTextToElementByPartialLinkText = (selectorValue, text, done) -> done(error)
     *   @sendTextToElementByTagName = (selectorValue, text, done) -> done(error)
     *   @sendTextToElementByXPath = (selectorValue, text, done) -> done(error)
     *   @sendTextToElementByCss = (selectorValue, text, done) -> done(error)
     */
    Jeeves.prototype['sendTextToElement' + _elFuncSuffix(type)] = function(selectorValue, text, done) {
      logger.test("@sendTextToElement" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this["getElement" + (_elFuncSuffix(type))](selectorValue, function(error, elem) {
        if (error) {
          return done(error);
        }
        logger.test("Element found! Attempting to type: " + text);
        return elem.sendKeys(text).nodeify(done);
      });
    };

    /*
     *   @clearAndSendTextByClassName = (selectorValue, text, done) -> done(error)
     *   @clearAndSendTextByCssSelector = (selectorValue, text, done) -> done(error)
     *   @clearAndSendTextById = (selectorValue, text, done) -> done(error)
     *   @clearAndSendTextByName = (selectorValue, text, done) -> done(error)
     *   @clearAndSendTextByLinkText = (selectorValue, text, done) -> done(error)
     *   @clearAndSendTextByPartialLinkText = (selectorValue, text, done) -> done(error)
     *   @clearAndSendTextByTagName = (selectorValue, text, done) -> done(error)
     *   @clearAndSendTextByXPath = (selectorValue, text, done) -> done(error)
     *   @clearAndSendTextByCss = (selectorValue, text, done) -> done(error)
     */
    Jeeves.prototype['clearAndSendText' + _elFuncSuffix(type)] = function(selectorValue, text, done) {
      logger.test("@clearAndSendText" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this["getElement" + (_elFuncSuffix(type))](selectorValue, function(error, elem) {
        if (error) {
          return done(error);
        }
        logger.test('Element found! Attempting to clear...');
        return elem.clear().then(function() {
          return logger.test("Element cleared! Attempting to type: " + text);
        }).type(text).nodeify(done);
      });
    };

    /*
     * Move to element, x and y offsets are optional.
     *   @mouseToElementByClassName = (selectorValue, xOffset, yOffset, done) -> done(error)
     *   @mouseToElementByCssSelector = (selectorValue, xOffset, yOffset, done) -> done(error)
     *   @mouseToElementById = (selectorValue, xOffset, yOffset, done) -> done(error)
     *   @mouseToElementByName = (selectorValue, xOffset, yOffset, done) -> done(error)
     *   @mouseToElementByLinkText = (selectorValue, xOffset, yOffset, done) -> done(error)
     *   @mouseToElementByPartialLinkText = (selectorValue, xOffset, yOffset, done) -> done(error)
     *   @mouseToElementByTagName = (selectorValue, xOffset, yOffset, done) -> done(error)
     *   @mouseToElementByXPath = (selectorValue, xOffset, yOffset, done) -> done(error)
     *   @mouseToElementByCss = (selectorValue, xOffset, yOffset, done) -> done(error)
     */
    Jeeves.prototype['mouseToElement' + _elFuncSuffix(type)] = function(selectorValue, xOffset, yOffset, done) {
      if (xOffset == null) {
        xOffset = 0;
      }
      if (yOffset == null) {
        yOffset = 0;
      }
      logger.test("@mouseToElement" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this["getElement" + (_elFuncSuffix(type))](selectorValue, function(error, elem) {
        if (error) {
          return done(error);
        }
        logger.test("Element found! Attempting to move mouse to element...offset( x: " + xOffset + ", y: " + yOffset + " )");
        return elem.moveTo(xOffset, yOffset).nodeify(done);
      });
    };

    /*
     * Double-clicks current mouse using on elem found w/ selectorValue
     *   @doubleClickElementByClassName = (selectorValue, offsets..., done) -> done(error)
     *   @doubleClickElementByCssSelector = (selectorValue, offsets..., done) -> done(error)
     *   @doubleClickElementById = (selectorValue, offsets..., done) -> done(error)
     *   @doubleClickElementByName = (selectorValue, offsets..., done) -> done(error)
     *   @doubleClickElementByLinkText = (selectorValue, offsets..., done) -> done(error)
     *   @doubleClickElementByPartialLinkText = (selectorValue, offsets..., done) -> done(error)
     *   @doubleClickElementByTagName = (selectorValue, offsets..., done) -> done(error)
     *   @doubleClickElementByXPath = (selectorValue, offsets..., done) -> done(error)
     *   @doubleClickElementByCss = (selectorValue, offsets..., done) -> done(error)
     */
    Jeeves.prototype['doubleClickElement' + _elFuncSuffix(type)] = function() {
      var done, offsets, selectorValue, xOffset, yOffset, _i, _ref1, _ref2;
      selectorValue = arguments[0], offsets = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
      logger.test("@doubleClickElement" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      xOffset = (_ref1 = offsets.shift()) != null ? _ref1 : 0;
      yOffset = (_ref2 = offsets.shift()) != null ? _ref2 : 0;
      return this["mouseToElement" + (_elFuncSuffix(type))](selectorValue, xOffset, yOffset, (function(_this) {
        return function(error) {
          if (error) {
            return done(error);
          }
          logger.test('Mouse in position! Attempting to double-click...');
          return _this.driver.doubleclick().nodeify(done);
        };
      })(this));
    };

    /*
     * Send mouseDown then mouseUp to elem found w/ selectorValue
     *   @mouseDownUpByClassName = (selectorValue, offsets..., done) -> done(error)
     *   @mouseDownUpByCssSelector = (selectorValue, offsets..., done) -> done(error)
     *   @mouseDownUpById = (selectorValue, offsets..., done) -> done(error)
     *   @mouseDownUpByName = (selectorValue, offsets..., done) -> done(error)
     *   @mouseDownUpByLinkText = (selectorValue, offsets..., done) -> done(error)
     *   @mouseDownUpByPartialLinkText = (selectorValue, offsets..., done) -> done(error)
     *   @mouseDownUpByTagName = (selectorValue, offsets..., done) -> done(error)
     *   @mouseDownUpByXPath = (selectorValue, offsets..., done) -> done(error)
     *   @mouseDownUpByCss = (selectorValue, offsets..., done) -> done(error)
     */
    Jeeves.prototype['mouseDownUp' + _elFuncSuffix(type)] = function() {
      var done, offsets, selectorValue, xOffset, yOffset, _i, _ref1, _ref2;
      selectorValue = arguments[0], offsets = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
      logger.test("@mouseDownUp" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      xOffset = (_ref1 = offsets.shift()) != null ? _ref1 : 0;
      yOffset = (_ref2 = offsets.shift()) != null ? _ref2 : 0;
      return this["mouseToElement" + (_elFuncSuffix(type))](selectorValue, xOffset, yOffset, (function(_this) {
        return function(error, elem) {
          if (error) {
            return done(error);
          }
          logger.test('Mouse in position! Attempting to mouseDown then mouseUp using left mouse button...');
          return _this.driver.buttonDown(0).buttonUp(0).nodeify(done);
        };
      })(this));
    };

    /*
     *   @mouseClickByClassName = (selectorValue, offsets..., done) -> done(error)
     *   @mouseClickByCssSelector = (selectorValue, offsets..., done) -> done(error)
     *   @mouseClickById = (selectorValue, offsets..., done) -> done(error)
     *   @mouseClickByName = (selectorValue, offsets..., done) -> done(error)
     *   @mouseClickByLinkText = (selectorValue, offsets..., done) -> done(error)
     *   @mouseClickByPartialLinkText = (selectorValue, offsets..., done) -> done(error)
     *   @mouseClickByTagName = (selectorValue, offsets..., done) -> done(error)
     *   @mouseClickByXPath = (selectorValue, offsets..., done) -> done(error)
     *   @mouseClickByCss = (selectorValue, offsets..., done) -> done(error)
     */
    Jeeves.prototype['mouseClick' + _elFuncSuffix(type)] = function() {
      var done, offsets, selectorValue, xOffset, yOffset, _i, _ref1, _ref2;
      selectorValue = arguments[0], offsets = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
      logger.test("@mouseClick" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      xOffset = (_ref1 = offsets.shift()) != null ? _ref1 : 0;
      yOffset = (_ref2 = offsets.shift()) != null ? _ref2 : 0;
      return this["mouseToElement" + (_elFuncSuffix(type))](selectorValue, xOffset, yOffset, (function(_this) {
        return function(error, elem) {
          if (error) {
            return done(error);
          }
          logger.test('Mouse in position! Attempting to click using left mouse button...');
          return _this.driver.click(0).nodeify(done);
        };
      })(this));
    };

    /*
     *   @isSelectedByClassName = (selectorValue, done) -> done(error, boolean)
     *   @isSelectedByCssSelector = (selectorValue, done) -> done(error, boolean)
     *   @isSelectedById = (selectorValue, done) -> done(error, boolean)
     *   @isSelectedByName = (selectorValue, done) -> done(error, boolean)
     *   @isSelectedByLinkText = (selectorValue, done) -> done(error, boolean)
     *   @isSelectedByPartialLinkText = (selectorValue, done) -> done(error, boolean)
     *   @isSelectedByTagName = (selectorValue, done) -> done(error, boolean)
     *   @isSelectedByXPath = (selectorValue, done) -> done(error, boolean)
     *   @isSelectedByCss = (selectorValue, done) -> done(error, boolean)
     */
    Jeeves.prototype['isSelected' + _elFuncSuffix(type)] = function(selectorValue, done) {
      logger.test("@isSelected" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this["getElement" + (_elFuncSuffix(type))](selectorValue, function(error, elem) {
        if (error) {
          return done(error);
        }
        logger.test('Element found! Attempting to check if selected...');
        return elem.isSelected().nodeify(function(error, selected) {
          if (!error) {
            logger.test("isSelected result: " + selected);
          }
          return done(error, selected);
        });
      });
    };

    /*
     *   @isEnabledByClassName = (selectorValue, done) -> done(error, boolean)
     *   @isEnabledByCssSelector = (selectorValue, done) -> done(error, boolean)
     *   @isEnabledById = (selectorValue, done) -> done(error, boolean)
     *   @isEnabledByName = (selectorValue, done) -> done(error, boolean)
     *   @isEnabledByLinkText = (selectorValue, done) -> done(error, boolean)
     *   @isEnabledByPartialLinkText = (selectorValue, done) -> done(error, boolean)
     *   @isEnabledByTagName = (selectorValue, done) -> done(error, boolean)
     *   @isEnabledByXPath = (selectorValue, done) -> done(error, boolean)
     *   @isEnabledByCss = (selectorValue, done) -> done(error, boolean)
     */
    Jeeves.prototype['isEnabled' + _elFuncSuffix(type)] = function(selectorValue, done) {
      logger.test("@isEnabled" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this["getElement" + (_elFuncSuffix(type))](selectorValue, function(error, elem) {
        if (error) {
          return done(error);
        }
        logger.test('Element found! Attempting to check if enabled...');
        return elem.isEnabled().nodeify(function(error, enabled) {
          if (!error) {
            logger.test("isEnabled result: " + enabled);
          }
          return done(error, enabled);
        });
      });
    };

    /*
     *   @isDisplayedByClassName = (selectorValue, done) -> done(error, boolean)
     *   @isDisplayedByCssSelector = (selectorValue, done) -> done(error, boolean)
     *   @isDisplayedById = (selectorValue, done) -> done(error, boolean)
     *   @isDisplayedByName = (selectorValue, done) -> done(error, boolean)
     *   @isDisplayedByLinkText = (selectorValue, done) -> done(error, boolean)
     *   @isDisplayedByPartialLinkText = (selectorValue, done) -> done(error, boolean)
     *   @isDisplayedByTagName = (selectorValue, done) -> done(error, boolean)
     *   @isDisplayedByXPath = (selectorValue, done) -> done(error, boolean)
     *   @isDisplayedByCss = (selectorValue, done) -> done(error, boolean)
     */
    Jeeves.prototype['isDisplayed' + _elFuncSuffix(type)] = function(selectorValue, done) {
      logger.test("@isDisplayed" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this["getElement" + (_elFuncSuffix(type))](selectorValue, function(error, elem) {
        if (!elem && (error != null ? error.message.match(/Error response status: 7/) : void 0)) {
          logger.test('Element not found');
          return done(null, false);
        } else if (error) {
          return done(error);
        }
        logger.test('Element found! Attempting to check if displayed...');
        return elem.isDisplayed().nodeify(function(error, displayed) {
          if (!error) {
            logger.test("isDisplayed result: " + displayed);
          }
          return done(error, displayed);
        });
      });
    };

    /*
     *   @isTextPresentByClassName = (selectorValue, searchText, done) -> done(error, boolean)
     *   @isTextPresentByCssSelector = (selectorValue, searchText, done) -> done(error, boolean)
     *   @isTextPresentById = (selectorValue, searchText, done) -> done(error, boolean)
     *   @isTextPresentByName = (selectorValue, searchText, done) -> done(error, boolean)
     *   @isTextPresentByLinkText = (selectorValue, searchText, done) -> done(error, boolean)
     *   @isTextPresentByPartialLinkText = (selectorValue, searchText, done) -> done(error, boolean)
     *   @isTextPresentByTagName = (selectorValue, searchText, done) -> done(error, boolean)
     *   @isTextPresentByXPath = (selectorValue, searchText, done) -> done(error, boolean)
     *   @isTextPresentByCss = (selectorValue, searchText, done) -> done(error, boolean)
     */
    Jeeves.prototype['isTextPresent' + _elFuncSuffix(type)] = function(selectorValue, searchText, done) {
      logger.test("@isTextPresent" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this["getElement" + (_elFuncSuffix(type))](selectorValue, function(error, elem) {
        if (error) {
          return done(error);
        }
        logger.test("Element found! Attempting to check for text: " + searchText);
        return elem.textPresent(searchText).nodeify(function(error, textFound) {
          if (!error) {
            logger.test("Text found: " + textFound);
          }
          return done(error, textFound);
        });
      });
    };

    /*
     *   @checkForElementByClassName = (selectorValue, done) -> done(error, boolean)
     *   @checkForElementByCssSelector = (selectorValue, done) -> done(error, boolean)
     *   @checkForElementById = (selectorValue, done) -> done(error, boolean)
     *   @checkForElementByName = (selectorValue, done) -> done(error, boolean)
     *   @checkForElementByLinkText = (selectorValue, done) -> done(error, boolean)
     *   @checkForElementByPartialLinkText = (selectorValue, done) -> done(error, boolean)
     *   @checkForElementByTagName = (selectorValue, done) -> done(error, boolean)
     *   @checkForElementByXPath = (selectorValue, done) -> done(error, boolean)
     *   @checkForElementByCss = (selectorValue, done) -> done(error, boolean)
     */
    Jeeves.prototype['checkForElement' + _elFuncSuffix(type)] = function(selectorValue, done) {
      logger.test("@checkForElement" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this.driver["hasElement" + (_elFuncSuffix(type))](selectorValue).nodeify((function(_this) {
        return function(error, exists) {
          logger.test("@checkForElement" + (_elFuncSuffix(type)) + " result: " + exists);
          return done(error, exists);
        };
      })(this));
    };

    /*
     *   @getTextByClassName = (selectorValue, opts..., done) -> done(error, text)
     *   @getTextByCssSelector = (selectorValue, opts..., done) -> done(error, text)
     *   @getTextById = (selectorValue, opts..., done) -> done(error, text)
     *   @getTextByName = (selectorValue, opts..., done) -> done(error, text)
     *   @getTextByLinkText = (selectorValue, opts..., done) -> done(error, text)
     *   @getTextByPartialLinkText = (selectorValue, opts..., done) -> done(error, text)
     *   @getTextByTagName = (selectorValue, opts..., done) -> done(error, text)
     *   @getTextByXPath = (selectorValue, opts..., done) -> done(error, text)
     *   @getTextByCss = (selectorValue, opts..., done) -> done(error, text)
     */
    Jeeves.prototype['getText' + _elFuncSuffix(type)] = function() {
      var callCount, done, opts, selectorValue, _i;
      selectorValue = arguments[0], opts = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
      logger.test("@getText" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      callCount = opts.shift() || 1;
      if (callCount > 2) {
        return done(new Error('getText() is in a loop of Error response status: 10'));
      }
      return this["getElement" + (_elFuncSuffix(type))](selectorValue, (function(_this) {
        return function(error, elem) {
          if (error) {
            return done(error);
          }
          logger.test('Element found! Attempting to get text...');
          return elem.text().nodeify(function(error, innerText) {
            if (error != null ? error.message.match(/Error response status: 10/) : void 0) {
              return _this["getText" + (_elFuncSuffix(type))](selectorValue, callCount + 1, done);
            } else {
              return done(error, innerText);
            }
          });
        };
      })(this));
    };

    /*
     *   @getAttributeValueByClassName = (selectorValue, attrName, done) -> done(error, attrValue)
     *   @getAttributeValueByCssSelector = (selectorValue, attrName, done) -> done(error, attrValue)
     *   @getAttributeValueById = (selectorValue, attrName, done) -> done(error, attrValue)
     *   @getAttributeValueByName = (selectorValue, attrName, done) -> done(error, attrValue)
     *   @getAttributeValueByLinkText = (selectorValue, attrName, done) -> done(error, attrValue)
     *   @getAttributeValueByPartialLinkText = (selectorValue, attrName, done) -> done(error, attrValue)
     *   @getAttributeValueByTagName = (selectorValue, attrName, done) -> done(error, attrValue)
     *   @getAttributeValueByXPath = (selectorValue, attrName, done) -> done(error, attrValue)
     *   @getAttributeValueByCss = (selectorValue, attrName, done) -> done(error, attrValue)
     */
    Jeeves.prototype['getAttributeValue' + _elFuncSuffix(type)] = function(selectorValue, attrName, done) {
      logger.test("@getAttributeValue" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this["getElement" + (_elFuncSuffix(type))](selectorValue, function(error, elem) {
        if (error) {
          return done(error);
        }
        logger.test("Element found! Attempting to get attribute(" + attrName + ")...");
        return elem.getAttribute(attrName).nodeify(function(error, attrVal) {
          if (!error) {
            logger.test("got attribute value: " + attrVal);
          }
          return done(error, attrVal);
        });
      });
    };

    /*
     *   @getComputedCssPropByClassName = (selectorValue, cssProp, done) -> done(error, computedCss)
     *   @getComputedCssPropByCssSelector = (selectorValue, cssProp, done) -> done(error, computedCss)
     *   @getComputedCssPropById = (selectorValue, cssProp, done) -> done(error, computedCss)
     *   @getComputedCssPropByName = (selectorValue, cssProp, done) -> done(error, computedCss)
     *   @getComputedCssPropByLinkText = (selectorValue, cssProp, done) -> done(error, computedCss)
     *   @getComputedCssPropByPartialLinkText = (selectorValue, cssProp, done) -> done(error, computedCss)
     *   @getComputedCssPropByTagName = (selectorValue, cssProp, done) -> done(error, computedCss)
     *   @getComputedCssPropByXPath = (selectorValue, cssProp, done) -> done(error, computedCss)
     *   @getComputedCssPropByCss = (selectorValue, cssProp, done) -> done(error, computedCss)
     */
    Jeeves.prototype['getComputedCssProp' + _elFuncSuffix(type)] = function(selectorValue, cssProp, done) {
      logger.test("@getComputedCssProp" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this["getElement" + (_elFuncSuffix(type))](selectorValue, function(error, elem) {
        if (error) {
          return done(error);
        }
        logger.test("Element found! Attempting to get computed css prop(" + cssProp + ")...");
        return elem.getComputedCss(cssProp).nodeify(function(error, cssPropVal) {
          if (!error) {
            logger.test("got computed css property: " + cssPropVal);
          }
          return done(error, cssPropVal);
        });
      });
    };

    /*
     *   @getSizeByClassName = (value, done) -> done(error, elemSize)
     *   @getSizeByCssSelector = (value, done) -> done(error, elemSize)
     *   @getSizeById = (value, done) -> done(error, elemSize)
     *   @getSizeByName = (value, done) -> done(error, elemSize)
     *   @getSizeByLinkText = (value, done) -> done(error, elemSize)
     *   @getSizeByPartialLinkText = (value, done) -> done(error, elemSize)
     *   @getSizeByTagName = (value, done) -> done(error, elemSize)
     *   @getSizeByXPath = (value, done) -> done(error, elemSize)
     *   @getSizeByCss = (value, done) -> done(error, elemSize)
     */
    Jeeves.prototype['getSize' + _elFuncSuffix(type)] = function(value, done) {
      logger.test("@getSize" + (_elFuncSuffix(type)) + " using " + value);
      return this["getElement" + (_elFuncSuffix(type))](value, function(error, elem) {
        if (error) {
          return done(error);
        }
        logger.test('Element found! Attempting to get elem size...');
        return elem.getSize().nodeify(function(error, elemSize) {
          if (!error) {
            logger.test("got elem size: " + elemSize);
          }
          return done(error, elemSize);
        });
      });
    };

    /*
     *   @getElemLocationByClassName = (selectorValue, done) -> done(error, elemLocation)
     *   @getElemLocationByCssSelector = (selectorValue, done) -> done(error, elemLocation)
     *   @getElemLocationById = (selectorValue, done) -> done(error, elemLocation)
     *   @getElemLocationByName = (selectorValue, done) -> done(error, elemLocation)
     *   @getElemLocationByLinkText = (selectorValue, done) -> done(error, elemLocation)
     *   @getElemLocationByPartialLinkText = (selectorValue, done) -> done(error, elemLocation)
     *   @getElemLocationByTagName = (selectorValue, done) -> done(error, elemLocation)
     *   @getElemLocationByXPath = (selectorValue, done) -> done(error, elemLocation)
     *   @getElemLocationByCss = (selectorValue, done) -> done(error, elemLocation)
     */
    Jeeves.prototype['getElemLocation' + _elFuncSuffix(type)] = function(selectorValue, done) {
      logger.test("@getElemLocation" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this["getElement" + (_elFuncSuffix(type))](selectorValue, function(error, elem) {
        if (error) {
          return done(error);
        }
        logger.test('Element found! Attempting to get location...');
        return elem.getLocation().nodeify(function(error, elemLoc) {
          if (!error) {
            logger.test('got elem location: ', elemLoc);
          }
          return done(error, elemLoc);
        });
      });
    };

    /*
     *   @getElemLocationInViewByClassName = (selectorValue, done) -> done(error, elemLocation)
     *   @getElemLocationInViewByCssSelector = (selectorValue, done) -> done(error, elemLocation)
     *   @getElemLocationInViewById = (selectorValue, done) -> done(error, elemLocation)
     *   @getElemLocationInViewByName = (selectorValue, done) -> done(error, elemLocation)
     *   @getElemLocationInViewByLinkText = (selectorValue, done) -> done(error, elemLocation)
     *   @getElemLocationInViewByPartialLinkText = (selectorValue, done) -> done(error, elemLocation)
     *   @getElemLocationInViewByTagName = (selectorValue, done) -> done(error, elemLocation)
     *   @getElemLocationInViewByXPath = (selectorValue, done) -> done(error, elemLocation)
     *   @getElemLocationInViewByCss = (selectorValue, done) -> done(error, elemLocation)
     */
    Jeeves.prototype['getElemLocationInView' + _elFuncSuffix(type)] = function(selectorValue, done) {
      logger.test("@getElemLocationInView" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      return this["getElement" + (_elFuncSuffix(type))](selectorValue, function(error, elem) {
        if (error) {
          return done(error);
        }
        logger.test('Element found! Attempting to get location in view...');
        return elem.getLocationInView().nodeify(function(error, elemLoc) {
          if (!error) {
            logger.test('got elem location in view: ', elemLoc);
          }
          return done(error, elemLoc);
        });
      });
    };

    /*
     *   @waitForElementByClassName = (selectorValue, options..., done) -> done(error)
     *   @waitForElementByCssSelector = (selectorValue, options..., done) -> done(error)
     *   @waitForElementById = (selectorValue, options..., done) -> done(error)
     *   @waitForElementByName = (selectorValue, options..., done) -> done(error)
     *   @waitForElementByLinkText = (selectorValue, options..., done) -> done(error)
     *   @waitForElementByPartialLinkText = (selectorValue, options..., done) -> done(error)
     *   @waitForElementByTagName = (selectorValue, options..., done) -> done(error)
     *   @waitForElementByXPath = (selectorValue, options..., done) -> done(error)
     *   @waitForElementByCss = (selectorValue, options..., done) -> done(error)
     */
    Jeeves.prototype['waitForElement' + _elFuncSuffix(type)] = function() {
      var done, interval, options, selectorValue, timeout, _i;
      selectorValue = arguments[0], options = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
      logger.test("@waitForElement" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      options = options.shift() || {};
      timeout = options.timeout, interval = options.interval;
      timeout = timeout != null ? timeout : SHORT_TIMEOUT;
      interval = interval != null ? interval : SHORT_INTERVAL;
      return this.driver["waitForElement" + (_elFuncSuffix(type))](selectorValue, timeout, SHORT_INTERVAL).nodeify(function(error) {
        if (!error) {
          logger.test('Waiting complete! Element exists on page');
        }
        return done(error);
      });
    };

    /*
     *   @waitForVisibleElementByClassName = (selectorValue, options..., done) -> done(error)
     *   @waitForVisibleElementByCssSelector = (selectorValue, options..., done) -> done(error)
     *   @waitForVisibleElementById = (selectorValue, options..., done) -> done(error)
     *   @waitForVisibleElementByName = (selectorValue, options..., done) -> done(error)
     *   @waitForVisibleElementByLinkText = (selectorValue, options..., done) -> done(error)
     *   @waitForVisibleElementByPartialLinkText = (selectorValue, options..., done) -> done(error)
     *   @waitForVisibleElementByTagName = (selectorValue, options..., done) -> done(error)
     *   @waitForVisibleElementByXPath = (selectorValue, options..., done) -> done(error)
     *   @waitForVisibleElementByCss = (selectorValue, options..., done) -> done(error)
     */
    Jeeves.prototype['waitForVisibleElement' + _elFuncSuffix(type)] = function() {
      var done, interval, options, selectorValue, timeout, _i;
      selectorValue = arguments[0], options = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
      logger.test("@waitForVisibleElement" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      options = options.shift() || {};
      timeout = options.timeout, interval = options.interval;
      timeout = timeout != null ? timeout : SHORT_TIMEOUT;
      interval = interval != null ? interval : SHORT_INTERVAL;
      return this.driver["waitForElement" + (_elFuncSuffix(type))](selectorValue, asserters.isDisplayed, timeout, interval).nodeify(function(error) {
        if (!error) {
          logger.test('Waiting complete! Element is visible');
        }
        return done(error);
      });
    };

    /*
     *   @waitForElementToHideByClassName = (selectorValue, options..., done) -> done(error)
     *   @waitForElementToHideByCssSelector = (selectorValue, options..., done) -> done(error)
     *   @waitForElementToHideById = (selectorValue, options..., done) -> done(error)
     *   @waitForElementToHideByName = (selectorValue, options..., done) -> done(error)
     *   @waitForElementToHideByLinkText = (selectorValue, options..., done) -> done(error)
     *   @waitForElementToHideByPartialLinkText = (selectorValue, options..., done) -> done(error)
     *   @waitForElementToHideByTagName = (selectorValue, options..., done) -> done(error)
     *   @waitForElementToHideByXPath = (selectorValue, options..., done) -> done(error)
     *   @waitForElementToHideByCss = (selectorValue, options..., done) -> done(error)
     */
    Jeeves.prototype['waitForElementToHide' + _elFuncSuffix(type)] = function() {
      var done, interval, options, selectorValue, timeout, _i;
      selectorValue = arguments[0], options = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
      logger.test("@waitForElementToHide" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      options = options.shift() || {};
      timeout = options.timeout, interval = options.interval;
      timeout = timeout != null ? timeout : SHORT_TIMEOUT;
      interval = interval != null ? interval : SHORT_INTERVAL;
      return this.driver["waitForElement" + (_elFuncSuffix(type))](selectorValue, asserters.isNotDisplayed, timeout, interval).nodeify(function(error) {
        if (!error) {
          logger.test('Waiting complete! Element is hidden');
        }
        return done(error);
      });
    };

    /*
     *   @waitForAndGetElementByClassName = (selectorValue, options..., done) -> done(error, elem)
     *   @waitForAndGetElementByCssSelector = (selectorValue, options..., done) -> done(error, elem)
     *   @waitForAndGetElementById = (selectorValue, options..., done) -> done(error, elem)
     *   @waitForAndGetElementByName = (selectorValue, options..., done) -> done(error, elem)
     *   @waitForAndGetElementByLinkText = (selectorValue, options..., done) -> done(error, elem)
     *   @waitForAndGetElementByPartialLinkText = (selectorValue, options..., done) -> done(error, elem)
     *   @waitForAndGetElementByTagName = (selectorValue, options..., done) -> done(error, elem)
     *   @waitForAndGetElementByXPath = (selectorValue, options..., done) -> done(error, elem)
     *   @waitForAndGetElementByCss = (selectorValue, options..., done) -> done(error, elem)
     */
    Jeeves.prototype['waitForAndGetElement' + _elFuncSuffix(type)] = function() {
      var done, interval, options, selectorValue, timeout, visibleElem, waitForMethod, _i;
      selectorValue = arguments[0], options = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
      logger.test("@waitForAndGetElement" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      options = options.shift() || {};
      timeout = options.timeout, interval = options.interval, visibleElem = options.visibleElem;
      timeout = timeout != null ? timeout : SHORT_TIMEOUT;
      interval = interval != null ? interval : SHORT_INTERVAL;
      if (visibleElem === true) {
        waitForMethod = "waitForVisibleElement" + (_elFuncSuffix(type));
      } else {
        waitForMethod = "waitForElement" + (_elFuncSuffix(type));
      }
      return this[waitForMethod](selectorValue, {
        timeout: timeout,
        interval: interval
      }, (function(_this) {
        return function(error) {
          if (error) {
            return done(error);
          }
          if (!error) {
            logger.test('Waiting complete! Attempting to get & return element...');
          }
          return _this["getElement" + (_elFuncSuffix(type))](selectorValue, done);
        };
      })(this));
    };

    /*
     *   @waitForAndGetElementsByClassName = (selectorValue, options..., done) -> done(error, elems)
     *   @waitForAndGetElementsByCssSelector = (selectorValue, options..., done) -> done(error, elems)
     *   @waitForAndGetElementsById = (selectorValue, options..., done) -> done(error, elems)
     *   @waitForAndGetElementsByName = (selectorValue, options..., done) -> done(error, elems)
     *   @waitForAndGetElementsByLinkText = (selectorValue, options..., done) -> done(error, elems)
     *   @waitForAndGetElementsByPartialLinkText = (selectorValue, options..., done) -> done(error, elems)
     *   @waitForAndGetElementsByTagName = (selectorValue, options..., done) -> done(error, elems)
     *   @waitForAndGetElementsByXPath = (selectorValue, options..., done) -> done(error, elems)
     *   @waitForAndGetElementsByCss = (selectorValue, options..., done) -> done(error, elems)
     */
    Jeeves.prototype['waitForAndGetElements' + _elFuncSuffix(type)] = function() {
      var done, interval, options, selectorValue, timeout, _i;
      selectorValue = arguments[0], options = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
      logger.test("@waitForAndGetElements" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      options = options.shift() || {};
      timeout = options.timeout, interval = options.interval;
      timeout = timeout != null ? timeout : SHORT_TIMEOUT;
      interval = interval != null ? interval : SHORT_INTERVAL;
      return this.driver["waitForElement" + (_elFuncSuffix(type))](selectorValue, timeout, interval).nodeify((function(_this) {
        return function(error) {
          if (error) {
            return done(error);
          }
          if (!error) {
            logger.test('Waiting complete! Attempting to get & return element...');
          }
          return _this["getElements" + (_elFuncSuffix(type))](selectorValue, done);
        };
      })(this));
    };

    /*
     *   @waitForTextByClassName = (selectorValue, options..., done) -> done(error)
     *   @waitForTextByCssSelector = (selectorValue, options..., done) -> done(error)
     *   @waitForTextById = (selectorValue, options..., done) -> done(error)
     *   @waitForTextByName = (selectorValue, options..., done) -> done(error)
     *   @waitForTextByLinkText = (selectorValue, options..., done) -> done(error)
     *   @waitForTextByPartialLinkText = (selectorValue, options..., done) -> done(error)
     *   @waitForTextByTagName = (selectorValue, options..., done) -> done(error)
     *   @waitForTextByXPath = (selectorValue, options..., done) -> done(error)
     *   @waitForTextByCss = (selectorValue, options..., done) -> done(error)
     */
    Jeeves.prototype['waitForText' + _elFuncSuffix(type)] = function() {
      var done, interval, options, selectorValue, timeout, _i;
      selectorValue = arguments[0], options = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
      logger.test("@waitForText" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      options = options.shift() || {};
      timeout = options.timeout, interval = options.interval;
      timeout = timeout != null ? timeout : SHORT_TIMEOUT;
      interval = interval != null ? interval : SHORT_INTERVAL;
      return this.driver["waitForElement" + (_elFuncSuffix(type))](selectorValue, asserters.nonEmptyText, timeout, interval).nodeify(function(error) {
        if (!error) {
          logger.test('Waiting complete, element text is not empty.');
        }
        return done(error);
      });
    };

    /*
     *   @waitForElementTextByClassName = (selectorValue, text, options..., done) -> done(error, boolean)
     *   @waitForElementTextByCssSelector = (selectorValue, text, options..., done) -> done(error, boolean)
     *   @waitForElementTextById = (selectorValue, text, options..., done) -> done(error, boolean)
     *   @waitForElementTextByName = (selectorValue, text, options..., done) -> done(error, boolean)
     *   @waitForElementTextByLinkText = (selectorValue, text, options..., done) -> done(error, boolean)
     *   @waitForElementTextByPartialLinkText = (selectorValue, text, options..., done) -> done(error, boolean)
     *   @waitForElementTextByTagName = (selectorValue, text, options..., done) -> done(error, boolean)
     *   @waitForElementTextByXPath = (selectorValue, text, options..., done) -> done(error, boolean)
     *   @waitForElementTextByCss = (selectorValue, text, options..., done) -> done(error, boolean)
     */
    Jeeves.prototype['waitForElementText' + _elFuncSuffix(type)] = function() {
      var done, interval, options, selectorValue, text, timeout, _i;
      selectorValue = arguments[0], text = arguments[1], options = 4 <= arguments.length ? __slice.call(arguments, 2, _i = arguments.length - 1) : (_i = 2, []), done = arguments[_i++];
      logger.test("@waitForElementText" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue + ", expected text: " + text);
      options = options.shift() || {};
      timeout = options.timeout, interval = options.interval;
      timeout = timeout != null ? timeout : SHORT_TIMEOUT;
      interval = interval != null ? interval : SHORT_INTERVAL;
      return this.driver["waitForElement" + (_elFuncSuffix(type))](selectorValue, asserters.textInclude(text), timeout, interval).nodeify(function(error) {
        if (!error) {
          logger.test("Waiting complete, element text is " + text);
        }
        return done(error);
      });
    };

    /*
     *   @waitForAndGetTextByClassName = (selectorValue, options..., done) -> done(error, text)
     *   @waitForAndGetTextByCssSelector = (selectorValue, options..., done) -> done(error, text)
     *   @waitForAndGetTextById = (selectorValue, options..., done) -> done(error, text)
     *   @waitForAndGetTextByName = (selectorValue, options..., done) -> done(error, text)
     *   @waitForAndGetTextByLinkText = (selectorValue, options..., done) -> done(error, text)
     *   @waitForAndGetTextByPartialLinkText = (selectorValue, options..., done) -> done(error, text)
     *   @waitForAndGetTextByTagName = (selectorValue, options..., done) -> done(error, text)
     *   @waitForAndGetTextByXPath = (selectorValue, options..., done) -> done(error, text)
     *   @waitForAndGetTextByCss = (selectorValue, options..., done) -> done(error, text)
     */
    Jeeves.prototype['waitForAndGetText' + _elFuncSuffix(type)] = function() {
      var done, interval, options, selectorValue, timeout, _i;
      selectorValue = arguments[0], options = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
      logger.test("@waitForAndGetText" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      options = options.shift() || {};
      timeout = options.timeout, interval = options.interval;
      timeout = timeout != null ? timeout : SHORT_TIMEOUT;
      interval = interval != null ? interval : SHORT_INTERVAL;
      return this["waitForAndGetElement" + (_elFuncSuffix(type))](selectorValue, {
        timeout: timeout,
        interval: interval
      }, (function(_this) {
        return function(error, elem) {
          if (error) {
            return done(error);
          }
          logger.test('Element found! Attempting to get text...');
          return elem.text().nodeify(function(error, text) {
            logger.test("Got text? => " + text);
            return done(error, text);
          });
        };
      })(this));
    };

    /*
     *   @waitForAndClickElementByClassName = (selectorValue, options..., done) -> done(error)
     *   @waitForAndClickElementByCssSelector = (selectorValue, options..., done) -> done(error)
     *   @waitForAndClickElementById = (selectorValue, options..., done) -> done(error)
     *   @waitForAndClickElementByName = (selectorValue, options..., done) -> done(error)
     *   @waitForAndClickElementByLinkText = (selectorValue, options..., done) -> done(error)
     *   @waitForAndClickElementByPartialLinkText = (selectorValue, options..., done) -> done(error)
     *   @waitForAndClickElementByTagName = (selectorValue, options..., done) -> done(error)
     *   @waitForAndClickElementByXPath = (selectorValue, options..., done) -> done(error)
     *   @waitForAndClickElementByCss = (selectorValue, options..., done) -> done(error)
     */
    return Jeeves.prototype['waitForAndClickElement' + _elFuncSuffix(type)] = function() {
      var done, interval, options, selectorValue, timeout, _i;
      selectorValue = arguments[0], options = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
      logger.test("@waitForAndClickElement" + (_elFuncSuffix(type)) + " using selectorValue: " + selectorValue);
      options = options.shift() || {};
      timeout = options.timeout, interval = options.interval;
      timeout = timeout != null ? timeout : SHORT_TIMEOUT;
      interval = interval != null ? interval : SHORT_INTERVAL;
      return this["waitForAndGetElement" + (_elFuncSuffix(type))](selectorValue, {
        timeout: timeout,
        interval: interval,
        visibleElem: true
      }, (function(_this) {
        return function(error, elem) {
          if (error) {
            return done(error);
          }
          logger.test('Element found! Attempting to click...');
          return elem.click().nodeify(done);
        };
      })(this));
    };
  });

}).call(this);
